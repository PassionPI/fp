"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const S=0,f=20,d=10,v=t=>typeof t!="number"?d:Math.floor(Math.max(S,Math.min(f,t))),{freeze:_,create:D}=Object;class w extends Array{}const q=t=>t instanceof w,y=t=>q(t)?t[0]?t:y():_(w.of(t instanceof Error?t:Error(typeof t=="object"?JSON.stringify(t):String(t)),null)),P=t=>q(t)?t:_(w.of(null,t)),h=[P,y],m=t=>new Proxy(t,{async apply(...e){try{return P(await Reflect.apply(...e))}catch(n){return y(n)}}}),j=()=>{let t=()=>{},e=()=>{};const n=new Promise((u,a)=>{[t,e]=[u,a]}),r=m(()=>n),c=()=>n;return r.unwrap=c,{resolve:t,reject:e,pending:r}},E=({max_concurrency:t=2}={})=>{const e={max_concurrency:t,current_count:0,queue:Array.from({length:f+1},()=>new Set)},n=s=>{if(s!=null){const o=v(s);return e.queue[o]}for(let o=f;o>=0;o--)if(e.queue[o].size>0)return e.queue[o];return e.queue[d]},r=(s,{priority:o}={})=>{const l=j(),i=n(o??d),p=l.resolve,b=l.pending,g=z=>{l.reject(z),i.delete(x)},x={task:s,resolve:p,reject:g};return i.add(x),a(),{pending:b,reject:g}},c=()=>e.current_count===e.max_concurrency,u=s=>{let o=n(s);for(;o.size;)o.forEach(l=>l.reject()),o.clear(),o=n(s)},a=()=>{let s=n();for(;!c()&&s.size;){e.current_count++;const o=s.values().next().value,{task:l,reject:i,resolve:p}=o;s.delete(o),s=n(),Promise.resolve().then(l).then(p).catch(i).finally(()=>{e.current_count--,a()})}};return{add:r,busy:c,clear:u}},M=(...t)=>e=>{for(const n of t)e=n(e);return e},R=(...t)=>async e=>{for(const n of t)e=n(await e);return e},T=t=>{let e=null;return new Proxy(t,{async apply(...n){e==null&&(e=Promise.resolve(Reflect.apply(...n)));const r=await e;return e=null,r}})},A=M(T,m),O=t=>{let e=!1,n;return(...r)=>(e||(e=!0,n=t(...r)),n)},I=(t,e)=>{const n=(t==null?void 0:t.length)??0;return r=>{const c=async u=>u<n?await t[u](r,O(()=>c(u+1))):await e(r);return c(0)}};class L extends Promise{pipe(e){return super.then(n=>n[0]?n:e(n[1])).then(...h)}ap(e){return super.then(n=>n[0]?n:n[1](e)).then(...h)}}const N=t=>L.resolve(t).then(...h),U=t=>{const e=new Map;return{get(n){const r=e.get(n);return e.has(n)&&(e.delete(n),e.set(n,r)),r},set(n,r){e.has(n)&&e.delete(n),e.set(n,r),e.size>t&&e.delete(e.keys().next().value)}}},B=t=>new Promise(e=>setTimeout(e,t));exports.LRU=U;exports.async_pipe=R;exports.concurrent=E;exports.defer=j;exports.either=m;exports.lock=A;exports.onion=I;exports.pipe=M;exports.pipeline=N;exports.wait=B;
