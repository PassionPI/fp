"use strict";var z=(t,e,s)=>{if(!e.has(t))throw TypeError("Cannot "+s)};var r=(t,e,s)=>(z(t,e,"read from private field"),s?s.call(t):e.get(t)),u=(t,e,s)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,s)},i=(t,e,s,n)=>(z(t,e,"write to private field"),n?n.call(t,s):e.set(t,s),s),y=(t,e,s,n)=>({set _(l){i(t,e,l,s)},get _(){return r(t,e,n)}});Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});class E{constructor(e){this.next=null,this.value=e}}var a,h,o;class O{constructor(){u(this,a,null);u(this,h,null);u(this,o,0)}size(){return r(this,o)}clear(){i(this,a,null),i(this,h,null),i(this,o,0)}shift(){const e=r(this,a);return r(this,o)&&(i(this,a,e.next),y(this,o)._--),r(this,o)||(i(this,a,null),i(this,h,null)),e==null?void 0:e.value}push(e){const s=new E(e);r(this,o)?(r(this,h).next=s,i(this,h,s)):(i(this,a,s),i(this,h,s)),y(this,o)._++}}a=new WeakMap,h=new WeakMap,o=new WeakMap;var d,f,p,w;const j=class{constructor(e){u(this,d,void 0);u(this,f,void 0);u(this,p,void 0);u(this,w,void 0);i(this,f,0),i(this,p,new O),this.add=n=>new Promise((l,c)=>{r(this,p).push({task:n,resolve:l,reject:c}),r(this,w).call(this)}),this.busy=()=>r(this,f)===r(this,d),this.clear=()=>{r(this,p).clear()},i(this,w,()=>{for(;!this.busy()&&r(this,p).size()>0;){const{task:n,reject:l,resolve:c}=r(this,p).shift();y(this,f)._++,Promise.resolve().then(n).then(c).catch(l).finally(()=>{y(this,f)._--,r(this,w).call(this)})}});const{max_concurrency:s}=e||{};i(this,d,s??2)}static of(...e){return new j(...e)}};let x=j;d=new WeakMap,f=new WeakMap,p=new WeakMap,w=new WeakMap;const{freeze:L,create:D}=Object;class P extends Array{}const _=t=>t instanceof P,g=t=>_(t)?t[0]?t:g():L(P.of(t instanceof Error?t:Error(typeof t=="object"?JSON.stringify(t):String(t)),null)),R=t=>_(t)?t:L(P.of(null,t)),m=[R,g],b=t=>new Proxy(t,{async apply(...e){try{return R(await Reflect.apply(...e))}catch(s){return g(s)}}}),k=()=>{let t,e;const s=new Promise((c,T)=>{[t,e]=[c,T]}),n=b(()=>s),l=()=>s;return n.unwrap=l,{resolve:t,reject:e,pending:n}},S=(...t)=>e=>{for(const s of t)e=s(e);return e},M=(...t)=>async e=>{for(const s of t)e=s(await e);return e},N=t=>{let e=null;return new Proxy(t,{async apply(...s){e==null&&(e=Promise.resolve(Reflect.apply(...s)));const n=await e;return e=null,n}})},U=S(N,b),q=t=>{let e=!1,s;return(...n)=>(e||(e=!0,s=t(...n)),s)},v=(t,e)=>{const s=(t==null?void 0:t.length)??0;return n=>{const l=async c=>c<s?await t[c](n,q(()=>l(c+1))):await e(n);return l(0)}};class A extends Promise{pipe(e){return super.then(s=>s[0]?s:e(s[1])).then(...m)}ap(e){return super.then(s=>s[0]?s:s[1](e)).then(...m)}}const B=t=>A.resolve(t).then(...m),J=t=>{const e=new Map;return{get(s){const n=e.get(s);return e.has(s)&&(e.delete(s),e.set(s,n)),n},set(s,n){e.has(s)&&e.delete(s),e.set(s,n),e.size>t&&e.delete(e.keys().next().value)}}},V=t=>new Promise(e=>setTimeout(e,t));exports.Concurrent=x;exports.LRU=J;exports.async_pipe=M;exports.defer=k;exports.either=b;exports.lock=U;exports.oni=v;exports.pipe=S;exports.pipeline=B;exports.wait=V;
